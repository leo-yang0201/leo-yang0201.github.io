<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java面试题汇总（三） | Leo Yang&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并发三要素是什么？ 可见性指一个线程对共享变量的修改，另外一个线程能够立刻看到，可见性问题一般由CPU缓存引起 123456&#x2F;&#x2F;线程1执行的代码int i &#x3D; 0;i &#x3D; 10; &#x2F;&#x2F;线程2执行的代码j &#x3D; i;  假如执行线程1的是CPU1，执行线程2的是CPU2，当线程1执行i &#x3D; 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值就变为">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试题汇总（三）">
<meta property="og:url" content="https://leo-yang0201.github.io/2020/03/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97%E4%B8%89/index.html">
<meta property="og:site_name" content="Leo Yang&#39;s Blog">
<meta property="og:description" content="并发三要素是什么？ 可见性指一个线程对共享变量的修改，另外一个线程能够立刻看到，可见性问题一般由CPU缓存引起 123456&#x2F;&#x2F;线程1执行的代码int i &#x3D; 0;i &#x3D; 10; &#x2F;&#x2F;线程2执行的代码j &#x3D; i;  假如执行线程1的是CPU1，执行线程2的是CPU2，当线程1执行i &#x3D; 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值就变为">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/12/8ZwgMQ.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/18/8wGV1O.png">
<meta property="og:image" content="https://s1.ax1x.com/2020/03/27/G9vwN9.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/07/3vC6VU.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/07/3viQnP.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2020/03/08/3vV5fU.jpg">
<meta property="og:image" content="https://s1.ax1x.com/2020/04/01/GlDXrT.png">
<meta property="article:published_time" content="2020-03-07T08:30:04.000Z">
<meta property="article:modified_time" content="2020-04-01T04:08:20.433Z">
<meta property="article:author" content="Leo Yang">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/03/12/8ZwgMQ.png">
  
    <link rel="alternate" href="/leo-yang0201.github.io/atom.xml" title="Leo Yang&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/leo-yang0201.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/leo-yang0201.github.io/" id="logo">Leo Yang&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/leo-yang0201.github.io/" id="subtitle">记录一些技术随笔和刷题思路～</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/#blog">首页</a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/archive">归档</a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/categories">分类</a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/tags">标签</a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/">Home</a>
        
          <a class="main-nav-link" href="/leo-yang0201.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/leo-yang0201.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leo-yang0201.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java面试题模块三" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/leo-yang0201.github.io/2020/03/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97%E4%B8%89/" class="article-date">
  <time datetime="2020-03-07T08:30:04.000Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/leo-yang0201.github.io/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java面试题汇总（三）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="并发三要素是什么？"><a href="#并发三要素是什么？" class="headerlink" title="并发三要素是什么？"></a>并发三要素是什么？</h4><ul>
<li><p>可见性<br>指一个线程对共享变量的修改，另外一个线程能够立刻看到，可见性问题一般由CPU缓存引起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假如执行线程1的是CPU1，执行线程2的是CPU2，当线程1执行i = 10这句时，会先把i的初始值<strong>加载到CPU1的高速缓存中</strong>，然后赋值为10，那么在CPU1的高速缓存当中i的值就变为10了，却<strong>没有立即写入到主存当中</strong>。</p>
<p>此时线程2执行j = i，它会<strong>先去主存读取i的值</strong>并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。这就是可见性问题，线程1对变量修改后，线程2没有立即看到线程1修改的值。</p>
<a id="more"></a>
</li>
<li><p>原子性<br>指一个操作或者多个操作要么全部执行并且执行过程不会被任何因素打断，要么都不执行</p>
<p>转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减1000元，往账户B加1000元。</p>
<p>如果这两个操作不具备原子性，假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题，原子性问题通常由<strong>分时复用引起</strong></p>
</li>
<li><p>有序性<br>指程序执行的顺序按照代码的先后顺序执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">著作权归https://www.pdai.tech所有。</span></span><br><span class="line"><span class="comment">链接：https://www.pdai.tech/md/java/thread/java-thread-x-theorty.html</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src="https://s1.ax1x.com/2020/03/12/8ZwgMQ.png" alt></p>
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p>
</li>
</ul>
<h4 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h4><ul>
<li>并行指两个或者多个事件在同一时刻发生，并发是指两个或多个事件在同一时间间隔发生</li>
<li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件</li>
</ul>
<p>并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能</p>
<h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p>进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存单元，减少切换次数，从而提高效率。</p>
<p>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>
<h4 id="守护线程是什么？"><a href="#守护线程是什么？" class="headerlink" title="守护线程是什么？"></a>守护线程是什么？</h4><p>守护线程（即daemon thread)，是一个服务线程，即服务其他线程的线程</p>
<h4 id="创建线程有哪几种方式？"><a href="#创建线程有哪几种方式？" class="headerlink" title="创建线程有哪几种方式？"></a>创建线程有哪几种方式？</h4><ul>
<li>继承Thread类创建线程类<ul>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体代表了线程要完成的任务，因此run()被称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ul>
</li>
<li>通过Runnable接口创建线程类<ul>
<li>定义Runnable接口的实现类，重写该接口的run()方法，该方法的方法体同样是该线程的线程执行体</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ul>
</li>
<li>通过Callable和Future创建线程<ul>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值</li>
<li>创建Callable实现类的实例，并使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程</li>
<li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值</li>
</ul>
</li>
</ul>
<h4 id="说一下Runnable跟Callable的区别？"><a href="#说一下Runnable跟Callable的区别？" class="headerlink" title="说一下Runnable跟Callable的区别？"></a>说一下Runnable跟Callable的区别？</h4><ul>
<li>Runnable接口中的run方法的返回值是void，它做的事情只是执行run方法中的代码而已</li>
<li>Callable接口中的call方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获得执行的结果</li>
</ul>
<p>工具类Executor可以实现Runnable对象和Callable对象之间的相互转换。（<code>Executors.callable（Runnable task</code>）或 <code>Executors.callable（Runnable task，Object resule）</code>）。</p>
<h4 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h4><p>线程通常有五种状态：创建、就绪、运行、阻塞、死亡</p>
<ul>
<li>创建状态，在生成线程对象，并没有调用该对象的start方法，线程处于创建状态</li>
<li>就绪状态，当调用了线程对象的start方法之后，线程进入就绪状态，但是此时线程调度程序还没把该线程设置为当前线程，此时处于就绪状态。当线程运行后，从等待或者睡眠中回来以后，也会处于就绪状态。</li>
<li>运行状态，线程调度程序将处于就绪状态的线程设置为当前线程，此时线程进入运行状态，开始运行run方法中的代码</li>
<li>阻塞状态，线程正在运行时，被暂停，通常是为了等待某个事件的发生（比如某项资源就绪）之后再继续运行。sleep，suspend，wait等方法都可以导致线程阻塞</li>
<li>死亡状态，如果一个线程的run方法执行结束或调用stop方法之后，线程就会死亡，已经死亡的线程无法再使用start方法令其就绪。</li>
</ul>
<h4 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h4><p><img src="https://s1.ax1x.com/2020/03/18/8wGV1O.png" alt></p>
<h4 id="核心线程池ThreadPoolExecutor的参数？"><a href="#核心线程池ThreadPoolExecutor的参数？" class="headerlink" title="核心线程池ThreadPoolExecutor的参数？"></a>核心线程池ThreadPoolExecutor的参数？</h4><p>ThreadPoolExectutor有三个最重要的参数：</p>
<ul>
<li>corePoolSize: 核心线程数定义了最小可以同时运行的线程数量</li>
<li>maximumPoolSize: 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</li>
<li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存在队列中</li>
</ul>
<p>其他常见参数：</p>
<ul>
<li>keepAliveTime: 线程池中线程数量大于corePoolSize时候，如果没有新任务提交，核心线程外的线程不会立即销毁而是等待，直到等待时间超过keepAliveTime后才会被回收销毁</li>
<li>Unit: keepAliveTime的基本单位</li>
<li>threadFactory: executor创建新线程的时候会用到</li>
<li>Handler: 饱和策略</li>
</ul>
<h4 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a><strong>sleep() 和 wait() 有什么区别？</strong></h4><ul>
<li>sleep(): 此方法是Thread类的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争占用CPU的执行时间。因为是静态方法，它不能改变对象的机锁，当一个synchronized块中调用了sleep()方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象</li>
<li>wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程</li>
</ul>
<h4 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h4><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行，然后通过此Thread类调用方法run()来完成其运行状态，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程终止。然后CPU再调度其他线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的，如果直接调用run()，其实就相当于调用了一个普通函数而已，多线程执行时要使用start()方法而不是run()方法，start()方法不能多次调用否则抛出java.lang.IllegalStateException，run()方法可以多次调用，因为它只是一种正常的方法调用</p>
<h4 id="创建线程池有哪几种方式？"><a href="#创建线程池有哪几种方式？" class="headerlink" title="创建线程池有哪几种方式？"></a>创建线程池有哪几种方式？</h4><p>阿里巴巴Java开发手册中强制线程池不允许使用Executor去创建，而是通过ThreadPoolExecutor的方式，这样处理让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li>
</ul>
<p>方式一：通过构造方法来实现</p>
<p><img src="https://s1.ax1x.com/2020/03/27/G9vwN9.jpg" alt></p>
<p>方式二：通过Executor框架的工具类Executors来实现，可以创建三种类型的ThreadPoolExecutor</p>
<ul>
<li>newFixedThreadPool(int nThreads)</li>
</ul>
<p>创建一个<strong>固定</strong>长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<ul>
<li>newCachedThreadPool()</li>
</ul>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理规模，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制</p>
<ul>
<li>newSingleThreadExecutor()</li>
</ul>
<p>这是一个单线程的Exectutor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它，特点是能确保依照任务在队列里的顺序来串行执行</p>
<ul>
<li>newScheduledThreadPool(int corePoolSize)</li>
</ul>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer</p>
<h4 id="线程池有哪些状态？"><a href="#线程池有哪些状态？" class="headerlink" title="线程池有哪些状态？"></a>线程池有哪些状态？</h4><p>线程池有五种状态：Running、Shutdown、Stop、Tidying、Terminated</p>
<p><img src="https://s2.ax1x.com/2020/03/07/3vC6VU.png" alt="线程池各个状态切换框架图"></p>
<h4 id="线程池中submit-和execute-方法有何区别？"><a href="#线程池中submit-和execute-方法有何区别？" class="headerlink" title="线程池中submit()和execute()方法有何区别？"></a>线程池中submit()和execute()方法有何区别？</h4><ul>
<li>接收的参数不一样</li>
<li>submit有返回值，execute没有</li>
<li>submit方便Exception处理</li>
</ul>
<h4 id="在Java程序中怎么保证多线程的运行安全？"><a href="#在Java程序中怎么保证多线程的运行安全？" class="headerlink" title="在Java程序中怎么保证多线程的运行安全？"></a>在Java程序中怎么保证多线程的运行安全？</h4><p>线程安全在三个方面体现：</p>
<ul>
<li>原子性：提供互斥访问，同一个时刻只能有一个线程对数据进行操作(atomic, synchronized)</li>
<li>可见性： 一个线程对主内存的修改可以及时地被其他线程看到(synchornized, volatile)</li>
<li>有序性： 一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序(happens-before原则)</li>
</ul>
<h4 id="多线程锁的升级原理是什么？"><a href="#多线程锁的升级原理是什么？" class="headerlink" title="多线程锁的升级原理是什么？"></a>多线程锁的升级原理是什么？</h4><p>在Java中，锁共有四种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级，锁可以升级但不能降级</p>
<p><img src="https://s2.ax1x.com/2020/03/07/3viQnP.jpg" alt="锁升级的图示过程"></p>
<h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<h4 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a>怎么防止死锁？</h4><p>死锁的四个必要条件</p>
<ul>
<li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li>
<li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能已经被其他资源占有，此时请求阻塞，但又对自己获得资源保持不放</li>
<li>不可剥夺条件：指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li>
<li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述一个条件被破坏，就不会发生死锁。理解了死锁的原因，就可以最大可能地避免、预防和解除死锁。在系统设计阶段，应使用合理的分配算法确定资源，避免进程永久占据系统资源，也要防止进程在处于等待状态的情况下占有资源，对资源的分配要给予合理的规划。</p>
<h4 id="ThreadLocal-是什么？有哪些使用场景？"><a href="#ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="ThreadLocal 是什么？有哪些使用场景？"></a>ThreadLocal 是什么？有哪些使用场景？</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<h4 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h4><p>ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap中就会出现key为null的Entry。假如我们不做任何措施的话，value永远无法被GC回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，再调用set()、get()、remove()方法的时候，会清理掉key为null的记录。使用完ThreadLocal方法后，最好手动调用remove()方法</p>
<p>弱引用介绍：</p>
<p>如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列(ReferenceQueue)联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="说一下-synchronized-底层实现原理？"><a href="#说一下-synchronized-底层实现原理？" class="headerlink" title="说一下 synchronized 底层实现原理？"></a>说一下 synchronized 底层实现原理？</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进到临界区，同时保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h4 id="volatile作用？"><a href="#volatile作用？" class="headerlink" title="volatile作用？"></a>volatile作用？</h4><ul>
<li>保持内存可见性：所有线程都能看见共享内存的最新状态</li>
</ul>
<p>Java通过几种原子操作完成工作内存和主内存的交互：</p>
<ol>
<li>lock：作用于主内存，把变量标识为线程独占状态</li>
<li>unlock：作用于主内存，解除独占状态</li>
<li>read：作用主内存，把一个变量的值从主内存传输到线程的工作内存</li>
<li>load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中</li>
<li>use：作用于工作内存，把工作内存当中的一个变量值传给执行引擎</li>
<li>assign：作用于工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量</li>
<li>store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中</li>
<li>write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中</li>
</ol>
<h5 id="volatile如何保持内存可见性"><a href="#volatile如何保持内存可见性" class="headerlink" title="volatile如何保持内存可见性"></a>volatile如何保持内存可见性</h5><ul>
<li>read,load,use动作必须连续出现</li>
<li>assign,store,write动作必须连续出现</li>
</ul>
<p>所以使用volatile能够保证：</p>
<ul>
<li>每次读取前必须先从主内存刷新最新的值</li>
<li>每次写入后必须立即同步回主内存当中</li>
</ul>
<p>volatile关键字修饰的变量看到的随时是自己的最新值，线程1对变量的最新修改，对线程2是可见的</p>
<h5 id="volatile如何防止指令重排"><a href="#volatile如何防止指令重排" class="headerlink" title="volatile如何防止指令重排"></a>volatile如何防止指令重排</h5><p>被volatile修饰的变量编译成字节码文件时会多个lock指令，该指令在执行过程中会生成相应的内存屏障</p>
<ul>
<li>有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序</li>
<li>在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他线程本地内存中该变量副本无效</li>
</ul>
<h4 id="synchronized和volatile的区别是什么？"><a href="#synchronized和volatile的区别是什么？" class="headerlink" title="synchronized和volatile的区别是什么？"></a>synchronized和volatile的区别是什么？</h4><ul>
<li>volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</li>
<li>volatile仅能使用在变量级别，synchronized可以使用在变量、方法、和类级别的</li>
<li>volatile仅能实现变量的修改可见性，不能保证原子性，synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li>
<li>volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化</li>
</ul>
<h4 id="synchronized和Lock有什么区别？"><a href="#synchronized和Lock有什么区别？" class="headerlink" title="synchronized和Lock有什么区别？"></a>synchronized和Lock有什么区别？</h4><ul>
<li>首先synchronized是Java内置关键字，在JVM层面，Lock是一个java类</li>
<li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁</li>
<li>synchronized会自动释放锁(A线程执行完同步代码会释放锁；B线程执行过程中发生异常会释放锁)，Lock需要在finally里手动释放锁(unlock()方法释放锁)，否则容易造成线程死锁</li>
<li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2等待，如果线程1阻塞，线程2会一直等待下去，而Lock锁就不会一直等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了</li>
<li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平</li>
<li>Lock锁适合大量同步的代码的同步问题，synchronized适合代码少量的同步问题</li>
</ul>
<h4 id="synchronized和ReentrantLock的区别是什么？"><a href="#synchronized和ReentrantLock的区别是什么？" class="headerlink" title="synchronized和ReentrantLock的区别是什么？"></a>synchronized和ReentrantLock的区别是什么？</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： </p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 </li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知 </li>
</ul>
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word</p>
<h4 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><p>New一个Thread，线程进入了新建状态；调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结：调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</p>
<h4 id="说一下-atomic-的原理"><a href="#说一下-atomic-的原理" class="headerlink" title="说一下 atomic 的原理?"></a>说一下 atomic 的原理?</h4><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>
<h4 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h4><p>CAS（Compare And Swap 比较并且替换）是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。</p>
<h4 id="CAS-是怎么实现线程安全的？"><a href="#CAS-是怎么实现线程安全的？" class="headerlink" title="CAS 是怎么实现线程安全的？"></a>CAS 是怎么实现线程安全的？</h4><p>线程在读取数据时不进行加锁，在准备写回数据时，先去查询原值，操作的时候比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p>
<p>他是乐观锁的一种实现，就是说认为数据总是不会被更改，我是乐观的仔，每次我都觉得你不会渣我，差不多是这个意思。</p>
<p>相比之下synchronized是悲观锁，不管哪个线程运行到这个方法时都要检查是否有其他线程正在用这个方法或该类的其他同步方法，有就要等正在使用synchronized方法的的线程运行完以后再运行此线程</p>
<h4 id="乐观锁和悲观锁总结"><a href="#乐观锁和悲观锁总结" class="headerlink" title="乐观锁和悲观锁总结"></a>乐观锁和悲观锁总结</h4><p><img src="https://s2.ax1x.com/2020/03/08/3vV5fU.jpg" alt></p>
<h4 id="AQS原理分析介绍一下？"><a href="#AQS原理分析介绍一下？" class="headerlink" title="AQS原理分析介绍一下？"></a>AQS原理分析介绍一下？</h4><p>AQS的全程为(AbstractQueuedSynchronizer)，这个类在java.util.concurrent.lock包下面。</p>
<p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p>AQS核心思想是，如果请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且被共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p>
<p>看个AQS(AbstractQueuedSynchronized)原理图：<br><img src="https://s1.ax1x.com/2020/04/01/GlDXrT.png" alt></p>
<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作</p>
<p>AQS使用CAS对该同步状态进行原子操作实现对其值的修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可⻅性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值) protected final boolean compareAndSetState(int expect, int update) &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br></pre></td></tr></table></figure>

<h5 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h5><h5 id="AQS定义两种资源共享方式"><a href="#AQS定义两种资源共享方式" class="headerlink" title="AQS定义两种资源共享方式"></a>AQS定义两种资源共享方式</h5><ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>Share（共享）：多个线程可同时执行，如Semaphore/ CountDownLatch。 Semaphore、CountDownLatch、CyclicBarrier、ReadWriteLock我们都会在后面讲到</li>
</ul>
<p>ReentrantReadWriteLock可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h5 id><a href="#" class="headerlink" title></a></h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://leo-yang0201.github.io/2020/03/07/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97%E4%B8%89/" data-id="cknf0jc79000i72nf2pps7fvz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/leo-yang0201.github.io/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/leo-yang0201.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/leo-yang0201.github.io/2020/03/08/Leetcode-322-Coin-Change/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Leetcode 322 Coin Change(零钱兑换)
        
      </div>
    </a>
  
  
    <a href="/leo-yang0201.github.io/2020/03/06/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A8%A1%E5%9D%97%E4%BA%8C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java面试题汇总（二）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/Blockchain/">Blockchain</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/Http/">Http</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/">Web服务器</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/leetcode/">leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/">分布式存储</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java/">Java</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/">分布式存储</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E6%B5%8B%E8%AF%95/">测试</a></li><li class="category-list-item"><a class="category-list-link" href="/leo-yang0201.github.io/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/AWS/" rel="tag">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Array/" rel="tag">Array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/BFS/" rel="tag">BFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Backtracking/" rel="tag">Backtracking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Binary-Search/" rel="tag">Binary Search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Bit-Manipulation/" rel="tag">Bit Manipulation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Brainteaser/" rel="tag">Brainteaser</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/CMU-course/" rel="tag">CMU course</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/ConcurrentHashMap/" rel="tag">ConcurrentHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Design/" rel="tag">Design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Dynamic-Programming/" rel="tag">Dynamic Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Hash-Table/" rel="tag">Hash Table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Heap/" rel="tag">Heap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Hyperledger/" rel="tag">Hyperledger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Minitax/" rel="tag">Minitax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Queue/" rel="tag">Queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/S3/" rel="tag">S3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Sliding-Window/" rel="tag">Sliding Window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Sort/" rel="tag">Sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Stack/" rel="tag">Stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/String/" rel="tag">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Two-Pointers/" rel="tag">Two Pointers</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/Union-Find/" rel="tag">Union Find</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/tree/" rel="tag">tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E5%85%A8%E6%A0%88/" rel="tag">全栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" rel="tag">字节跳动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" rel="tag">数据仓库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/leo-yang0201.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" rel="tag">软件测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/leo-yang0201.github.io/tags/AWS/" style="font-size: 10px;">AWS</a> <a href="/leo-yang0201.github.io/tags/Array/" style="font-size: 20px;">Array</a> <a href="/leo-yang0201.github.io/tags/BFS/" style="font-size: 13.85px;">BFS</a> <a href="/leo-yang0201.github.io/tags/Backtracking/" style="font-size: 10.77px;">Backtracking</a> <a href="/leo-yang0201.github.io/tags/Binary-Search/" style="font-size: 12.31px;">Binary Search</a> <a href="/leo-yang0201.github.io/tags/Bit-Manipulation/" style="font-size: 11.54px;">Bit Manipulation</a> <a href="/leo-yang0201.github.io/tags/Brainteaser/" style="font-size: 10px;">Brainteaser</a> <a href="/leo-yang0201.github.io/tags/CMU-course/" style="font-size: 10px;">CMU course</a> <a href="/leo-yang0201.github.io/tags/ConcurrentHashMap/" style="font-size: 10px;">ConcurrentHashMap</a> <a href="/leo-yang0201.github.io/tags/DFS/" style="font-size: 15.38px;">DFS</a> <a href="/leo-yang0201.github.io/tags/Design/" style="font-size: 13.08px;">Design</a> <a href="/leo-yang0201.github.io/tags/Dynamic-Programming/" style="font-size: 19.23px;">Dynamic Programming</a> <a href="/leo-yang0201.github.io/tags/Hash-Table/" style="font-size: 13.08px;">Hash Table</a> <a href="/leo-yang0201.github.io/tags/Heap/" style="font-size: 10px;">Heap</a> <a href="/leo-yang0201.github.io/tags/Hyperledger/" style="font-size: 10px;">Hyperledger</a> <a href="/leo-yang0201.github.io/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/leo-yang0201.github.io/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 14.62px;">Java基础</a> <a href="/leo-yang0201.github.io/tags/LinkedList/" style="font-size: 17.69px;">LinkedList</a> <a href="/leo-yang0201.github.io/tags/Math/" style="font-size: 10.77px;">Math</a> <a href="/leo-yang0201.github.io/tags/Minitax/" style="font-size: 10px;">Minitax</a> <a href="/leo-yang0201.github.io/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/leo-yang0201.github.io/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/leo-yang0201.github.io/tags/Queue/" style="font-size: 10.77px;">Queue</a> <a href="/leo-yang0201.github.io/tags/S3/" style="font-size: 10px;">S3</a> <a href="/leo-yang0201.github.io/tags/Sliding-Window/" style="font-size: 10.77px;">Sliding Window</a> <a href="/leo-yang0201.github.io/tags/Sort/" style="font-size: 11.54px;">Sort</a> <a href="/leo-yang0201.github.io/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/leo-yang0201.github.io/tags/Stack/" style="font-size: 16.15px;">Stack</a> <a href="/leo-yang0201.github.io/tags/String/" style="font-size: 14.62px;">String</a> <a href="/leo-yang0201.github.io/tags/Two-Pointers/" style="font-size: 16.92px;">Two Pointers</a> <a href="/leo-yang0201.github.io/tags/Union-Find/" style="font-size: 10px;">Union Find</a> <a href="/leo-yang0201.github.io/tags/math/" style="font-size: 10px;">math</a> <a href="/leo-yang0201.github.io/tags/tree/" style="font-size: 18.46px;">tree</a> <a href="/leo-yang0201.github.io/tags/%E5%85%A8%E6%A0%88/" style="font-size: 10px;">全栈</a> <a href="/leo-yang0201.github.io/tags/%E5%88%86%E6%B2%BB/" style="font-size: 10px;">分治</a> <a href="/leo-yang0201.github.io/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/leo-yang0201.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/leo-yang0201.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/" style="font-size: 10px;">字节跳动</a> <a href="/leo-yang0201.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/leo-yang0201.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/" style="font-size: 10px;">数据仓库</a> <a href="/leo-yang0201.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/leo-yang0201.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 13.08px;">贪心算法</a> <a href="/leo-yang0201.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">软件测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/leo-yang0201.github.io/archive/2019/12/">December 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/leo-yang0201.github.io/2021/01/07/SnowFlake%E7%9F%A5%E8%AF%86%E7%82%B9/">SnowFlake知识点</a>
          </li>
        
          <li>
            <a href="/leo-yang0201.github.io/2020/12/21/Http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">Http常见面试题</a>
          </li>
        
          <li>
            <a href="/leo-yang0201.github.io/2020/11/29/JVM-%E7%AC%94%E8%AE%B0/">JVM 笔记</a>
          </li>
        
          <li>
            <a href="/leo-yang0201.github.io/2020/11/22/Amazon-S3-%E7%AC%94%E8%AE%B0/">Amazon S3 笔记</a>
          </li>
        
          <li>
            <a href="/leo-yang0201.github.io/2020/07/06/Nginx%E9%9D%A2%E8%AF%95/">Nginx面试整理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Leo Yang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/leo-yang0201.github.io/#blog" class="mobile-nav-link">首页</a>
  
    <a href="/leo-yang0201.github.io/archive" class="mobile-nav-link">归档</a>
  
    <a href="/leo-yang0201.github.io/categories" class="mobile-nav-link">分类</a>
  
    <a href="/leo-yang0201.github.io/tags" class="mobile-nav-link">标签</a>
  
    <a href="/leo-yang0201.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/leo-yang0201.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/leo-yang0201.github.io/fancybox/jquery.fancybox.css">

  
<script src="/leo-yang0201.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/leo-yang0201.github.io/js/script.js"></script>




  </div>
</body>
</html>